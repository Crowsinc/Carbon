#include "Texture.hpp"

namespace cbn
{

	//-------------------------------------------------------------------------------------

	Res<Texture> Texture::Create(const Image& image, const Properties& properties)
	{
		// Create the texture. This can only fail if the graphics device is out of memory
		// so we don't actually have to worry about validating any of the given parameters
		Texture texture(image, properties);

		// If we could not properly create the texture do to 
		// being out of memory destroy the texture and fail creation
		if(glGetError() == GL_OUT_OF_MEMORY)
		{
			Delete(texture);
			return nullptr;
		}

		return Res<Texture>::Wrap(texture, &Texture::Delete);
	}
	
	//-------------------------------------------------------------------------------------

	Res<Texture> Texture::Open(const std::filesystem::path& path, const Properties& properties)
	{
		// First open the image, making sure to flip on the y-axis since OpenGL 
		// has (0,0) on the bottom left while the image has (0,0) on the top left. 
		Res<Image> image = Image::Open(path, true);
		if(!image.exists())
			return nullptr;

		// Continue with the normal create function 
		return Create(image, properties);
	}
	
	//-------------------------------------------------------------------------------------

	void Texture::upload_image_data(const Image::Pixel* data, const unsigned width, const unsigned height)
	{
		// We need to bind the image before we can update its contents
		bind();

		glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA8, width, height, 0, GL_RGBA, GL_UNSIGNED_BYTE, data);
	}
	//-------------------------------------------------------------------------------------

	std::array<GLint, 4> Texture::generate_swizzle_mask(const SwizzleMask swizzle_type) const
	{
		switch(swizzle_type) 
		{
			default:
			case SwizzleMask::RGBA: return {GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA};

			case SwizzleMask::BGRA: return {GL_BLUE, GL_GREEN, GL_RED, GL_ALPHA};

			case SwizzleMask::RGB: return {GL_RED, GL_GREEN, GL_BLUE, GL_ONE};

			case SwizzleMask::BGR: return {GL_BLUE, GL_GREEN, GL_RED, GL_ONE};
		}
	}
	
	//-------------------------------------------------------------------------------------

	Texture::Texture(const Image& image, const Properties& properties)
		: GLTypedObject(glGenTextures, nullptr, glBindTexture)
	{
		// The super constructor creates the texture, so we just need to 
		// set its parameters and then upload the texture data
		configure(properties);
		
		// Note that this can fail if the graphics device is out of memory,
		// however the error is generated by the device not OpenGL so it must 
		// be validated independently in the create function.
		upload_image_data(image.data(), image.width(), image.height());
	}
	
	//-------------------------------------------------------------------------------------

	void Texture::Delete(Texture& texture)
	{
		glDeleteTextures(1, &texture.m_ObjectID);
	}
	
	//-------------------------------------------------------------------------------------

	Texture::Texture(Texture&& texture) noexcept
		: GLTypedObject(static_cast<GLTypedObject&&>(texture)),
		m_Properties(texture.m_Properties),
		m_Resolution(texture.m_Resolution) {}
	
	//-------------------------------------------------------------------------------------

	void Texture::configure(const Properties& properties)
	{
		// We need to bind the texture before we can change its parameters
		bind();

		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, static_cast<GLint>(properties.horizontal_wrapping));
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, static_cast<GLint>(properties.vertical_wrapping));
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, static_cast<GLint>(properties.minifying_filter));
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, static_cast<GLint>(properties.magnifying_filter));
	
		// Update the swizzle mask
		auto mask = generate_swizzle_mask(properties.swizzle_mask);
		glTexParameteriv(GL_TEXTURE_2D, GL_TEXTURE_SWIZZLE_RGBA, mask.data());

		// Update the stored properties
		m_Properties = properties;
	}
	
	//-------------------------------------------------------------------------------------

	Texture::Properties Texture::get_properties() const
	{
		return m_Properties;
	}
	
	//-------------------------------------------------------------------------------------

	const unsigned Texture::width() const
	{
		return m_Resolution.x;
	}
	
	//-------------------------------------------------------------------------------------

	const unsigned Texture::height() const
	{
		return m_Resolution.y;
	}
	
	//-------------------------------------------------------------------------------------

	glm::uvec2 Texture::resolution() const
	{
		return m_Resolution;
	}
	
	//-------------------------------------------------------------------------------------

	void Texture::operator=(Texture&& texture)
	{
		GLTypedObject::operator=(static_cast<GLTypedObject&&>(texture));
		m_Properties = texture.m_Properties;
		m_Resolution = texture.m_Resolution;
	}
	
	//-------------------------------------------------------------------------------------

}