#include "Texture.hpp"

namespace cbn
{

	//-------------------------------------------------------------------------------------
	
	// Zero initialize a raw array then convert it to a std array. All texture units will
	// be unbound initially. 
	std::array<GLuint, 32> Texture::s_BoundTexture2Ds = std::to_array<GLuint, 32>({0});
	
	//-------------------------------------------------------------------------------------

	SRes<Texture> Texture::Create(const SRes<Image>& image, const TextureSettings& settings)
	{
		// Create the texture. This can only fail if the graphics device is out of memory
		// so we don't actually have to worry about validating any of the given parameters
		SRes<Texture> texture = Resource::WrapShared(new Texture(image, settings));

		// If we could not properly create the texture due to 
		// being out of memory, run the texture out of scope
		// so it is destroyed and fail creation
		if(glGetError() == GL_OUT_OF_MEMORY)
		{
			return nullptr;
		}

		return texture;
	}
	
	//-------------------------------------------------------------------------------------

	SRes<Texture> Texture::Open(const std::filesystem::path& path, const TextureSettings& settings)
	{
		SRes<Image> image = Image::Open(path);
		if(!image)
			return nullptr;

		return Create(image, settings);
	}

	//-------------------------------------------------------------------------------------

	GLint Texture::SupportedTextureUnits()
	{
		GLint texture_units;
		glGetIntegerv(GL_MAX_TEXTURE_IMAGE_UNITS, &texture_units);
		return texture_units;
	}
	
	//-------------------------------------------------------------------------------------

	void Texture::upload_image_data(const Colour* data, const unsigned width, const unsigned height)
	{
		// We need to bind the image before we can update its contents
		bind();

		glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA8, width, height, 0, GL_RGBA, GL_UNSIGNED_BYTE, data);
	}

	//-------------------------------------------------------------------------------------

	std::array<GLint, 4> Texture::create_swizzle_mask(const TextureSwizzle swizzle)
	{
		switch(swizzle)
		{
			case TextureSwizzle::RGBA:
				return std::array<GLint, 4>{GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA};
			case TextureSwizzle::BGRA:
				return std::array<GLint, 4>{GL_BLUE, GL_GREEN, GL_RED, GL_ALPHA};
			case TextureSwizzle::RGB:
				return std::array<GLint, 4>{GL_RED, GL_GREEN, GL_BLUE, GL_ONE};
			case TextureSwizzle::BGR:
				return std::array<GLint, 4>{GL_BLUE, GL_GREEN, GL_RED, GL_ONE};
			default:
				return {};
		}
	}
	
	//-------------------------------------------------------------------------------------

	Texture::Texture(const SRes<Image>& image, const TextureSettings& settings)
		: m_Resolution(image->resolution())
	{
		// Create the texture
		glGenTextures(1, &m_TextureID);

		// Configure texture properties
		configure(settings);
		
		// Note that this can fail if the graphics device is out of memory,
		// however the error is generated by the device not OpenGL so it must 
		// be validated independently in the create function.
		upload_image_data(image->data(), image->width(), image->height());
	}
	
	//-------------------------------------------------------------------------------------

	Texture::~Texture()
	{
		// Before we destroy the object, we need to ensure the static bounded object tracker
		// doesnt consider it as being bound. Otherwise issues will arise when a new object
		// takes its ID. 
		unbind();
		glDeleteTextures(1, &m_TextureID);
	}
	
	//-------------------------------------------------------------------------------------

	bool Texture::is_bound(const TextureUnit texture_unit) const
	{
		return m_TextureUnit == texture_unit && s_BoundTexture2Ds[value(texture_unit)] == m_TextureID;
	}

	//-------------------------------------------------------------------------------------

	bool Texture::is_bound() const
	{
		return s_BoundTexture2Ds[value(m_TextureUnit)] == m_TextureID;
	}

	//-------------------------------------------------------------------------------------

	void Texture::bind(const TextureUnit texture_unit) const
	{
		// Only bind the texture if it is not already 
		// bound to the given texture unit
		if(!is_bound(texture_unit))
		{
			// Update the texture binding states
			s_BoundTexture2Ds[value(texture_unit)] = m_TextureID;
			m_TextureUnit = texture_unit;

			// Bind the texture to the correct unit
			glActiveTexture(GL_TEXTURE0 +  value(texture_unit));
			glBindTexture(GL_TEXTURE_2D, m_TextureID);
		}
	}


	//-------------------------------------------------------------------------------------

	void Texture::unbind() const
	{
		// Only unbind if the texture is actually bound in the first place
		if(is_bound())
		{
			// Unbind from the texture unit the texture is bound to
			glActiveTexture(GL_TEXTURE0 + value(m_TextureUnit));
			glBindTexture(GL_TEXTURE_2D, 0);

			// Reset state information
			s_BoundTexture2Ds[value(m_TextureUnit)] = 0;
		}
	}

	//-------------------------------------------------------------------------------------

	void Texture::configure(const TextureSettings& settings)
	{
		// We need to bind the texture before we can change its parameters
		bind();

		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, value(settings.horizontal_wrapping));
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, value(settings.vertical_wrapping));
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, value(settings.minifying_filter));
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, value(settings.magnifying_filter));
	
		// Update the swizzle mask
		glTexParameteriv(GL_TEXTURE_2D, GL_TEXTURE_SWIZZLE_RGBA, create_swizzle_mask(settings.swizzle).data());

		// Update the stored properties
		m_Settings = settings;
	}
	
	//-------------------------------------------------------------------------------------

	TextureSettings Texture::settings() const
	{
		return m_Settings;
	}
	
	//-------------------------------------------------------------------------------------

	const unsigned Texture::width() const
	{
		return m_Resolution.x;
	}
	
	//-------------------------------------------------------------------------------------

	const unsigned Texture::height() const
	{
		return m_Resolution.y;
	}
	
	//-------------------------------------------------------------------------------------

	glm::uvec2 Texture::resolution() const
	{
		return m_Resolution;
	}

	//-------------------------------------------------------------------------------------

	TextureUVMap Texture::uvs() const
	{
		// Texture uvs just encompass the entire texture, so we can just hardcode them
		// Note that with texture coordinates, (0,0) is taken from the top left corner.

		return {{0.0f, 0.0f},  // Top left
			    {0.0f, 1.0f},  // Bottom Left
			    {1.0f, 1.0f},  // Bottom Right
			    {1.0f, 0.0f}}; // Top Right
	}

	//-------------------------------------------------------------------------------------



}