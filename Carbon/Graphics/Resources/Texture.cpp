#include "Texture.hpp"

namespace cbn
{

	//-------------------------------------------------------------------------------------

	SRes<Texture> Texture::Create(const SRes<Image>& image, const Properties& properties)
	{
		// Create the texture. This can only fail if the graphics device is out of memory
		// so we don't actually have to worry about validating any of the given parameters
		SRes<Texture> texture = Resource::WrapShared(new Texture(image, properties));

		// If we could not properly create the texture due to 
		// being out of memory, run the texture out of scope
		// so it is destroyed and fail creation
		if(glGetError() == GL_OUT_OF_MEMORY)
		{
			return nullptr;
		}

		return texture;
	}
	
	//-------------------------------------------------------------------------------------

	SRes<Texture> Texture::Open(const std::filesystem::path& path, const Properties& properties)
	{
		// First open the image, making sure to flip on the y-axis since OpenGL 
		// has (0,0) on the bottom left while the image has (0,0) on the top left. 
		SRes<Image> image = Image::Open(path, true);
		if(!image)
			return nullptr;

		// Continue with the normal create function 
		return Create(image, properties);
	}
	
	//-------------------------------------------------------------------------------------

	void Texture::upload_image_data(const Image::Pixel* data, const unsigned width, const unsigned height)
	{
		// We need to bind the image before we can update its contents
		bind();

		glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA8, width, height, 0, GL_RGBA, GL_UNSIGNED_BYTE, data);
	}	
	
	//-------------------------------------------------------------------------------------

	Texture::Texture(const SRes<Image>& image, const Properties& properties)
		: GLTypedObject(glGenTextures, glDeleteTextures, glBindTexture)
	{
		// The super constructor creates the texture, so we just need to 
		// set its parameters and then upload the texture data
		configure(properties);
		
		// Note that this can fail if the graphics device is out of memory,
		// however the error is generated by the device not OpenGL so it must 
		// be validated independently in the create function.
		upload_image_data(image->data(), image->width(), image->height());
	}
	
	//-------------------------------------------------------------------------------------

	void Texture::configure(const Properties& properties)
	{
		// We need to bind the texture before we can change its parameters
		bind();

		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, static_cast<GLint>(properties.horizontal_wrapping));
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, static_cast<GLint>(properties.vertical_wrapping));
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, static_cast<GLint>(properties.minifying_filter));
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, static_cast<GLint>(properties.magnifying_filter));
	
		// Update the swizzle mask
		glTexParameteriv(GL_TEXTURE_2D, GL_TEXTURE_SWIZZLE_RGBA, SwizzleMasks.at(properties.swizzle).data());

		// Update the stored properties
		m_Properties = properties;
	}
	
	//-------------------------------------------------------------------------------------

	Texture::Properties Texture::get_properties() const
	{
		return m_Properties;
	}
	
	//-------------------------------------------------------------------------------------

	const unsigned Texture::width() const
	{
		return m_Resolution.x;
	}
	
	//-------------------------------------------------------------------------------------

	const unsigned Texture::height() const
	{
		return m_Resolution.y;
	}
	
	//-------------------------------------------------------------------------------------

	glm::uvec2 Texture::resolution() const
	{
		return m_Resolution;
	}
	
	//-------------------------------------------------------------------------------------

}